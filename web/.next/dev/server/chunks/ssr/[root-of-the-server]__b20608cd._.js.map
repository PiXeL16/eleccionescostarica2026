{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 20, "column": 0}, "map": {"version":3,"sources":["file:///Users/christopher.jimenez/Src/Personal/Elecciones2026/web/lib/database.ts"],"sourcesContent":["// ABOUTME: Database connection layer for SQLite using better-sqlite3\n// ABOUTME: Provides read-only access to political party data\n\nimport Database from 'better-sqlite3';\nimport { join } from 'path';\n\n// Database path (shared with pipeline)\nconst DB_PATH = join(process.cwd(), '..', 'data', 'database.db');\n\n// Types\nexport interface Party {\n  id: number;\n  name: string;\n  abbreviation: string;\n  folder_name: string;\n  created_at: string;\n}\n\nexport interface Category {\n  id: number;\n  category_key: string;\n  name: string;\n  description: string;\n  prompt_context: string | null;\n  display_order: number;\n  active: number;\n  created_at: string;\n}\n\nexport interface PartyPosition {\n  id: number;\n  party_id: number;\n  category_id: number;\n  document_id: number;\n  summary: string;\n  key_proposals: string; // JSON array\n  ideology_position: string | null;\n  budget_mentioned: string | null;\n  confidence_score: number | null;\n  tokens_used: number | null;\n  cost_usd: number | null;\n  created_at: string;\n}\n\nexport interface PartyWithPositions extends Party {\n  positions: (PartyPosition & { category: Category })[];\n}\n\n// Database singleton\nlet db: Database.Database | null = null;\n\nfunction getDatabase() {\n  if (!db) {\n    db = new Database(DB_PATH, { readonly: true, fileMustExist: true });\n  }\n  return db;\n}\n\n/**\n * Get all political parties\n */\nexport function getAllParties(): Party[] {\n  const db = getDatabase();\n  const stmt = db.prepare('SELECT * FROM parties ORDER BY name');\n  return stmt.all() as Party[];\n}\n\n/**\n * Get a specific party by slug (abbreviation)\n */\nexport function getPartyBySlug(slug: string): Party | null {\n  const db = getDatabase();\n  const stmt = db.prepare('SELECT * FROM parties WHERE abbreviation = ?');\n  return (stmt.get(slug.toUpperCase()) as Party) || null;\n}\n\n/**\n * Get all categories\n */\nexport function getAllCategories(): Category[] {\n  const db = getDatabase();\n  const stmt = db.prepare('SELECT * FROM categories WHERE active = 1 ORDER BY display_order');\n  return stmt.all() as Category[];\n}\n\n/**\n * Get a category by key\n */\nexport function getCategoryByKey(key: string): Category | null {\n  const db = getDatabase();\n  const stmt = db.prepare('SELECT * FROM categories WHERE category_key = ? AND active = 1');\n  return (stmt.get(key) as Category) || null;\n}\n\n/**\n * Get party positions for a specific party\n */\nexport function getPartyPositions(partyId: number): (PartyPosition & { category: Category })[] {\n  const db = getDatabase();\n  const stmt = db.prepare(`\n    SELECT\n      pp.*,\n      c.id as category_id,\n      c.category_key,\n      c.name as category_name,\n      c.description as category_description,\n      c.display_order\n    FROM party_positions pp\n    JOIN categories c ON pp.category_id = c.id\n    WHERE pp.party_id = ? AND c.active = 1\n    ORDER BY c.display_order\n  `);\n\n  const rows = stmt.all(partyId) as any[];\n\n  return rows.map((row) => ({\n    id: row.id,\n    party_id: row.party_id,\n    category_id: row.category_id,\n    document_id: row.document_id,\n    summary: row.summary,\n    key_proposals: row.key_proposals,\n    ideology_position: row.ideology_position,\n    budget_mentioned: row.budget_mentioned,\n    confidence_score: row.confidence_score,\n    tokens_used: row.tokens_used,\n    cost_usd: row.cost_usd,\n    created_at: row.created_at,\n    category: {\n      id: row.category_id,\n      category_key: row.category_key,\n      name: row.category_name,\n      description: row.category_description,\n      prompt_context: null,\n      display_order: row.display_order,\n      active: 1,\n      created_at: '',\n    },\n  }));\n}\n\n/**\n * Get document for a party\n */\nexport function getPartyDocument(partyId: number) {\n  const db = getDatabase();\n  const stmt = db.prepare('SELECT * FROM documents WHERE party_id = ?');\n  return stmt.get(partyId);\n}\n\n/**\n * Get extracted text for a document (concatenates all pages)\n */\nexport function getDocumentText(documentId: number): string | null {\n  const db = getDatabase();\n  const stmt = db.prepare('SELECT raw_text FROM document_text WHERE document_id = ? ORDER BY page_number');\n  const results = stmt.all(documentId) as { raw_text: string }[];\n\n  if (results.length === 0) return null;\n\n  return results.map(r => r.raw_text).join('\\n\\n');\n}\n\n/**\n * Get a specific party with all its positions\n */\nexport function getPartyWithPositions(slug: string): PartyWithPositions | null {\n  const party = getPartyBySlug(slug);\n  if (!party) return null;\n\n  const positions = getPartyPositions(party.id);\n\n  return {\n    ...party,\n    positions,\n  };\n}\n\n/**\n * Compare multiple parties (for comparison page)\n */\nexport function compareParties(\n  slugs: string[]\n): { parties: Party[]; categories: Category[]; positions: Map<string, Map<string, PartyPosition>> } {\n  const parties = slugs.map((slug) => getPartyBySlug(slug)).filter((p): p is Party => p !== null);\n  const categories = getAllCategories();\n\n  // Build a map of party slug -> category key -> position\n  const positions = new Map<string, Map<string, PartyPosition>>();\n\n  for (const party of parties) {\n    const partyPositions = getPartyPositions(party.id);\n    const positionMap = new Map<string, PartyPosition>();\n\n    for (const pos of partyPositions) {\n      positionMap.set(pos.category.category_key, pos);\n    }\n\n    positions.set(party.abbreviation, positionMap);\n  }\n\n  return { parties, categories, positions };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 164, "column": 0}, "map": {"version":3,"sources":["file:///Users/christopher.jimenez/Src/Personal/Elecciones2026/web/components/ComparisonView.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const ComparisonView = registerClientReference(\n    function() { throw new Error(\"Attempted to call ComparisonView() from the server but ComparisonView is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/ComparisonView.tsx <module evaluation>\",\n    \"ComparisonView\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;AACO,MAAM,iBAAiB,IAAA,wQAAuB,EACjD;IAAa,MAAM,IAAI,MAAM;AAA4O,GACzQ,+DACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 178, "column": 0}, "map": {"version":3,"sources":["file:///Users/christopher.jimenez/Src/Personal/Elecciones2026/web/components/ComparisonView.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const ComparisonView = registerClientReference(\n    function() { throw new Error(\"Attempted to call ComparisonView() from the server but ComparisonView is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/ComparisonView.tsx\",\n    \"ComparisonView\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;AACO,MAAM,iBAAiB,IAAA,wQAAuB,EACjD;IAAa,MAAM,IAAI,MAAM;AAA4O,GACzQ,2CACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 192, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 200, "column": 0}, "map": {"version":3,"sources":["file:///Users/christopher.jimenez/Src/Personal/Elecciones2026/web/app/comparar/page.tsx"],"sourcesContent":["// ABOUTME: Comparison page for side-by-side party platform comparison\n// ABOUTME: Server component that loads all data and passes to client component\n\nimport { getAllParties, getAllCategories, compareParties } from '@/lib/database';\nimport { ComparisonView } from '@/components/ComparisonView';\n\nexport default function ComparePage() {\n  const allParties = getAllParties();\n  const allCategories = getAllCategories();\n\n  // Pre-fetch comparison data for all parties (will be filtered client-side)\n  const allSlugs = allParties.map((p) => p.abbreviation);\n  const comparisonData = allSlugs.length > 0 ? compareParties(allSlugs) : null;\n\n  return <ComparisonView allParties={allParties} allCategories={allCategories} comparisonData={comparisonData} />;\n}\n"],"names":[],"mappings":"AAAA,sEAAsE;AACtE,+EAA+E;;;;;;AAE/E;AACA;;;;AAEe,SAAS;IACtB,MAAM,aAAa,IAAA,gIAAa;IAChC,MAAM,gBAAgB,IAAA,mIAAgB;IAEtC,2EAA2E;IAC3E,MAAM,WAAW,WAAW,GAAG,CAAC,CAAC,IAAM,EAAE,YAAY;IACrD,MAAM,iBAAiB,SAAS,MAAM,GAAG,IAAI,IAAA,iIAAc,EAAC,YAAY;IAExE,qBAAO,8OAAC,+IAAc;QAAC,YAAY;QAAY,eAAe;QAAe,gBAAgB;;;;;;AAC/F","debugId":null}}]
}